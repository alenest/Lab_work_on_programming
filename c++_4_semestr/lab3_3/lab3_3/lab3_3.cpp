#include <iostream>
#include <vector>
#include <algorithm>
#include <stdexcept>
#include <limits>
#include <sstream>

using namespace std;

// Исключение для работы с множествами
class SetException : public exception {
private:
    string message;

public:
    SetException(const string& msg) : message(msg) {}

    const char* what() const noexcept override {
        return message.c_str();
    }
};

// Шаблонный класс Множество
template <typename T>
class Множество {
protected:
    vector<T> элементы; // Вектор для хранения элементов

public:
    // Добавление элемента в множество, если его ещё нет
    void добавитьЭлемент(const T& элемент) {
        if (содержитЭлемент(элемент)) {
            throw SetException("Элемент уже существует в множестве.");
        }
        элементы.push_back(элемент);
    }

    // Удаление элемента из множества
    void удалитьЭлемент(const T& элемент) {
        typename vector<T>::iterator it = find(элементы.begin(), элементы.end(), элемент);
        if (it == элементы.end()) {
            throw SetException("Элемент не найден в множестве.");
        }
        элементы.erase(it);
    }

    // Проверка, есть ли элемент в множестве
    bool содержитЭлемент(const T& элемент) const {
        return find(элементы.begin(), элементы.end(), элемент) != элементы.end();
    }

    // Вывод всех элементов множества
    void вывестиЭлементы() const {
        cout << "{ ";
        for (typename vector<T>::const_iterator it = элементы.begin(); it != элементы.end(); ++it) {
            cout << *it << " ";
        }
        cout << "}" << endl;
    }

    // Получение всех элементов множества
    const vector<T>& получитьЭлементы() const {
        return элементы;
    }
};

// Шаблонный класс для работы с цехами, наследующий Множество
template <typename T>
class ОперацииЦеха : public Множество<T> {
public:
    // Поиск уникальных операций для цеха среди всех цехов
    vector<T> найтиУникальныеОперации(const vector<ОперацииЦеха<T>>& всеЦеха) const {
        vector<T> уникальныеОперации;

        // Проверяем каждую операцию текущего цеха
        for (typename vector<T>::const_iterator it = this->элементы.begin(); it != this->элементы.end(); ++it) {
            bool уникальна = true;

            // Проверяем, есть ли эта операция в других цехах
            for (typename vector<ОперацииЦеха<T>>::const_iterator цех = всеЦеха.begin(); цех != всеЦеха.end(); ++цех) {
                if (&(*цех) != this && цех->содержитЭлемент(*it)) {
                    уникальна = false;
                    break;
                }
            }

            // Если операция уникальна, добавляем её в результат
            if (уникальна) {
                уникальныеОперации.push_back(*it);
            }
        }

        return уникальныеОперации;
    }

    // Поиск общих операций между двумя цехами
    vector<T> найтиОбщиеОперации(const ОперацииЦеха<T>& другойЦех) const {
        vector<T> общиеОперации;

        // Проверяем каждую операцию текущего цеха
        for (typename vector<T>::const_iterator it = this->элементы.begin(); it != this->элементы.end(); ++it) {
            if (другойЦех.содержитЭлемент(*it)) {
                общиеОперации.push_back(*it);
            }
        }

        return общиеОперации;
    }
};

// Функция для выбора типа данных и запуска программы
template<typename T>
void запуститьПрограмму() {
    int количествоЦехов;
    cout << "Введите количество цехов: ";
    cin >> количествоЦехов;

    vector<ОперацииЦеха<T>> цеха(количествоЦехов); // Список цехов

    // Ввод операций для каждого цеха
    for (int i = 0; i < количествоЦехов; ++i) {
        int количествоОпераций;
        cout << "Введите количество операций для цеха " << i + 1 << ": ";
        cin >> количествоОпераций;
        cout << "Введите операции для цеха " << i + 1 << ": ";
        for (int j = 0; j < количествоОпераций; ++j) {
            T операция;
            cin >> операция;
            цеха[i].добавитьЭлемент(операция); // Добавляем операцию в цех
        }
    }

    // Основной цикл программы
    bool running = true;
    while (running) {
        int цехA, цехB;
        cout << "\nВведите номера двух цехов для сравнения (через пробел) или 0 для выхода: ";
        cin >> цехA;

        if (цехA == 0) {
            running = false;
            cout << "Завершение работы программы." << endl;
            continue;
        }

        cin >> цехB;

        // Проверка корректности введенных номеров цехов
        if (цехA < 1 || цехA > количествоЦехов || цехB < 1 || цехB > количествоЦехов) {
            cerr << "Ошибка: некорректные номера цехов." << endl;
            continue;
        }

        // Поиск общих операций
        vector<T> общиеОперации = цеха[цехA - 1].найтиОбщиеОперации(цеха[цехB - 1]);
        if (общиеОперации.empty()) {
            cout << "Общих операций нет." << endl;
            continue; // Пропускаем дальнейшую обработку, если общих операций нет
        }
        else {
            cout << "Элементы, присутствующие в обоих цехах: ";
            for (typename vector<T>::const_iterator it = общиеОперации.begin(); it != общиеОперации.end(); ++it) {
                cout << *it << " ";
            }
            cout << endl;
        }

        // Поиск уникальных операций для каждого цеха среди всех цехов
        vector<T> уникальныеОперацииЦехаA = цеха[цехA - 1].найтиУникальныеОперации(цеха);
        vector<T> уникальныеОперацииЦехаB = цеха[цехB - 1].найтиУникальныеОперации(цеха);

        // Вывод результатов
        cout << "Уникальные операции для цеха " << цехA << ": ";
        if (!уникальныеОперацииЦехаA.empty()) {
            for (typename vector<T>::const_iterator it = уникальныеОперацииЦехаA.begin(); it != уникальныеОперацииЦехаA.end(); ++it) {
                cout << *it << " ";
            }
            cout << endl;
        }
        else {
            cout << "Уникальных операций нет." << endl;
        }

        cout << "Уникальные операции для цеха " << цехB << ": ";
        if (!уникальныеОперацииЦехаB.empty()) {
            for (typename vector<T>::const_iterator it = уникальныеОперацииЦехаB.begin(); it != уникальныеОперацииЦехаB.end(); ++it) {
                cout << *it << " ";
            }
            cout << endl;
        }
        else {
            cout << "Уникальных операций нет." << endl;
        }
    }
}

int main() {
    setlocale(LC_ALL, "Russian"); // Поддержка русского языка

    cout << "Выберите тип данных для операций:\n";
    cout << "1. int\n";
    cout << "2. double\n";
    cout << "3. string\n";
    cout << "Введите номер типа: ";

    int выбор;
    cin >> выбор;
    cin.ignore();

    switch (выбор) {
    case 1:
        запуститьПрограмму<int>();
        break;
    case 2:
        запуститьПрограмму<double>();
        break;
    case 3:
        запуститьПрограмму<string>();
        break;
    default:
        cout << "Неверный выбор. Завершение программы.\n";
        break;
    }

    return 0;
}